// gui/src/MainWindow.cpp

#include "MainWindow.hpp"

// Wrap C headers in extern "C" to prevent C++ name-mangling
extern "C" {
#include "../../simulate.h"    // simulate_stream, Config
#include "../../state.h"       // TRTS_State
}

#include "AnalyzerPanel.hpp"
#include "EngineConfigPanel.hpp"
#include "ExecutionPanel.hpp"
#include "FingerprintPanel.hpp"
#include "OutputTableWidget.hpp"
#include "PhaseMapExplorer.hpp"
#include "RhythmVisualizerWidget.hpp"
#include "StackViewerWidget.hpp"
#include "TheoristExplorerPanel.hpp"

#include <QAction>
#include <QDockWidget>
#include <QFileDialog>
#include <QFileInfo>
#include <QHBoxLayout>
#include <QLabel>
#include <QMenuBar>
#include <QMessageBox>
#include <QProcess>
#include <QStatusBar>
#include <QTabWidget>
#include <QToolBar>
#include <QStringList>

// Constructor / destructor
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_process(new TRTSCoreProcess(this))
{
    buildUi();
    connectSignals();
    setWindowTitle(tr("TRTS Lab Interface"));
}

MainWindow::~MainWindow() = default;

// Size hints
QSize MainWindow::minimumSizeHint() const {
    return QSize(800, 600);
}

QSize MainWindow::sizeHint() const {
    return QSize(1024, 768);
}

// UI setup
void MainWindow::buildUi()
{
    m_tabs = new QTabWidget(this);
    setCentralWidget(m_tabs);

    m_engineConfig = new EngineConfigPanel(this);
    m_execution    = new ExecutionPanel(this);
    m_rhythm       = new RhythmVisualizerWidget(this);
    m_stack        = new StackViewerWidget(this);
    m_analyzer     = new AnalyzerPanel(this);
    m_fingerprint  = new FingerprintPanel(this);
    m_phaseMap     = new PhaseMapExplorer(this);
    m_theorist     = new TheoristExplorerPanel(this);
    m_outputTable  = new OutputTableWidget(this);

    m_tabs->addTab(m_engineConfig, tr("Engine configuration"));
    m_tabs->addTab(m_execution,    tr("Execution"));
    m_tabs->addTab(m_rhythm,       tr("ψ rhythm"));
    m_tabs->addTab(m_stack,        tr("Stack"));
    m_tabs->addTab(m_analyzer,     tr("Analyzer"));
    m_tabs->addTab(m_fingerprint,  tr("Fingerprint"));
    m_tabs->addTab(m_phaseMap,     tr("Phase map"));
    m_tabs->addTab(m_theorist,     tr("Theorist"));
    m_tabs->addTab(m_outputTable,  tr("Output table"));

    auto *toolBar = addToolBar(tr("Controls"));
    m_actionStart      = toolBar->addAction(tr("Start"));
    m_actionStop       = toolBar->addAction(tr("Stop"));
    m_actionReset      = toolBar->addAction(tr("Reset"));
    toolBar->addSeparator();
    m_actionClear      = toolBar->addAction(tr("Clear state"));
    toolBar->addSeparator();
    m_actionLoadConfig = toolBar->addAction(tr("Load config"));

    statusBar();
    m_statusLabel = new QLabel(tr("Idle"), this);
    statusBar()->addPermanentWidget(m_statusLabel, 1);
}

// Signal wiring
void MainWindow::connectSignals()
{
    connect(m_actionStart,      &QAction::triggered, this, &MainWindow::handleStartRun);
    connect(m_actionStop,       &QAction::triggered, this, &MainWindow::handleStopRun);
    connect(m_actionReset,      &QAction::triggered, this, &MainWindow::handleReset);
    connect(m_actionClear,      &QAction::triggered, this, &MainWindow::handleClearOutput);
    connect(m_actionLoadConfig, &QAction::triggered, this, &MainWindow::handleLoadConfigRequested);

    connect(m_engineConfig, &EngineConfigPanel::configurationChanged,
            this, [this](const TRTSConfig &cfg) {
                Q_UNUSED(cfg);
                logStatus(tr("Configuration updated"));
            });
    connect(m_engineConfig, &EngineConfigPanel::requestLoadConfig,
            this, &MainWindow::handleLoadConfigRequested);

    connect(m_execution, &ExecutionPanel::runRequested,  this, &MainWindow::handleStartRun);
    connect(m_execution, &ExecutionPanel::stopRequested, this, &MainWindow::handleStopRun);
    connect(m_execution, &ExecutionPanel::resetRequested,this, &MainWindow::handleReset);

    // External‐process hooks (kept for reference)
    // connect(m_process, &TRTSCoreProcess::engineOutput, this, &MainWindow::handleEngineOutput);
    // connect(m_process, &TRTSCoreProcess::engineError,  this, &MainWindow::handleEngineError);
    // connect(m_process, &TRTSCoreProcess::runFinished,  this, &MainWindow::handleRunFinished);
}

// Start run: invoke streaming simulate
void MainWindow::handleStartRun()
{
    const TRTSConfig cfg = m_engineConfig->configuration();

    // Legacy external process (commented)
    // if (!m_process->startRun(cfg)) return;

    // Streaming API
    simulate_stream(
        reinterpret_cast<const Config*>(&cfg),
        MainWindow::guiObserver,
        this
    );
}

// Stop run (stub or external)
void MainWindow::handleStopRun()
{
    // m_process->stopRun();
}

// Reset run state
void MainWindow::handleReset()
{
    // if (m_process->isRunning()) m_process->stopRun();
    m_execution->resetState();
    m_outputTable->clear();
    m_rhythm->clearEvents();
    m_stack->clear();
    logStatus(tr("Engine reset"));
}

// Clear all panels
void MainWindow::handleClearOutput()
{
    m_execution->resetState();
    m_rhythm->clearEvents();
    m_stack->clear();
    m_analyzer->clearResults();
    m_fingerprint->clear();
    m_phaseMap->clear();
    m_theorist->clear();
    m_outputTable->clear();
    logStatus(tr("Cleared in-memory state"));
}

// Load config flow
void MainWindow::handleLoadConfigRequested()
{
    loadConfigFromFile();
}

// Read config from file
void MainWindow::loadConfigFromFile()
{
    const QString path = QFileDialog::getOpenFileName(
        this,
        tr("Select TRTS config"),
        {},
        tr("TRTS config (*.trtscfg)")
    );
    if (path.isEmpty()) return;
    m_engineConfig->loadConfigurationFromFile(path);
    logStatus(tr("Loaded configuration from %1").arg(QFileInfo(path).fileName()));
}

// Parse lines from external process (unused by streaming mode)
void MainWindow::parseEngineLine(const QString &line)
{
    const QStringList cols = line.split(';');
    if (cols.size() < 8) {
        appendLogEntry({line});
        return;
    }
    // existing parsing + panel updates...
}

// Handle legacy external‐process output
void MainWindow::handleEngineOutput(const QString &line)
{
    parseEngineLine(line);
}

// Handle legacy external‐process errors
void MainWindow::handleEngineError(const QString &line)
{
    logStatus(tr("Engine error: %1").arg(line));
}

// Handle legacy external‐process finish
void MainWindow::handleRunFinished(int exitCode, QProcess::ExitStatus)
{
    logStatus(tr("Engine finished with exit code %1").arg(exitCode));
}

// Utility: append to output table
void MainWindow::appendLogEntry(const QStringList &columns)
{
    m_outputTable->appendRow(columns);
}

// Utility: show status text
void MainWindow::logStatus(const QString &msg)
{
    m_statusLabel->setText(msg);
}

// Observer callback for streaming API
void MainWindow::guiObserver(void *userData,
                             size_t tick,
                             int microtick,
                             char phase,
                             const TRTS_State * /*state*/,
                             bool rho,
                             bool psi,
                             bool mu_zero,
                             bool forced)
{
    auto *self = static_cast<MainWindow*>(userData);
    emit self->engineUpdate(tick, microtick, phase, rho, psi, mu_zero, forced);
}

